apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: identity-database-data # Име на PVC ресурса (в рамките на namespace-а)
spec:
  accessModes:
  - ReadWriteOnce # RWO: може да бъде монтиран за писане от 1 node
  resources:
    requests:
      storage: 10Gi # Заявен размер на диска

---

apiVersion: v1
kind: Service
metadata:
  name: identity-database
spec:
  clusterIP: None
  ports:
  - port: 1433                  # PORT НА SERVICE-A (вътрешен за клъстера). Клиентите ще се връзват на identity-database:1433
    targetPort: 1433            # PORT В КОНТЕЙНЕРА (containerPort). Това е портът, на който SQL Server слуша вътре в pod-а
  selector:
    database: identity          # Service-ът избира pod-ове с този label (трябва да съвпада с labels в StatefulSet pod template)
    
---

apiVersion: apps/v1                         # Коя версия на Kubernetes API използваме за този ресурс
kind: StatefulSet                           # Какъв тип Kubernetes обект създаваме
metadata:                                   # информация за ресурса, а не самата му конфигурация
  name: identity-database                   # Името на StatefulSet-а в namespace-а
spec:                                       # описваме как трябва да изглежда и да се държи StatefulSet-ът
  serviceName: identity-database            # Името на Service-а, който StatefulSet-ът използва
  selector:                                 # Правило, с което StatefulSet-ът разпознава кои pod-ове са “негови”
    matchLabels:                            # Всички pod-ове с тези labels принадлежат към този StatefulSet
      database: identity                    # Конкретният label, по който става връзката
  template:                                 # Шаблон за pod-овете, които StatefulSet-ът ще създава
    metadata:                               # Метаданни за pod-а, не за StatefulSet-а
      labels:                               # Labels, които ще се сложат на всеки pod, създаден от този StatefulSet
        database: identity                  # Този label трябва да съвпада със selector.matchLabels
        system: database                    # Допълнителен label за организация и филтриране
    spec:
      terminationGracePeriodSeconds: 60     # Слагаме 60 секунди, за да има достатъчно време базата да спре нормално
      containers:                           # Започваме да си описваме контейнера
      - name: identity-database
        image: mcr.microsoft.com/mssql/server:2019-latest
        imagePullPolicy: IfNotPresent       # Тъй като image-ът е много голям искаме да избегнем излишни сваляния като кешираме
        ports:
        - containerPort: 1433
        resources:
          limits:
            memory: "2Gi"                   # Стойностите, които слагаме тук варират спрямо бизнес изискванията ни
            cpu: "1000m"
        env:                                # Environment variables за SQL Server контейнера
        - name: ACCEPT_EULA
          value: "Y"
        - name: SA_PASSWORD
          valueFrom:                        # Няма да пишем паролата директно в YAML-а
            secretKeyRef:                   # Взимаме стойността от Kubernetes Secret
              name: environment-secrets     # Име на Secret ресурса
              key: identity-database-sa-password # Ключът в Secret-а, където е паролата
        volumeMounts:                       # Казваме "къде в контейнера" да се монтира volume-a
        - name: identity-database-data      # Името на volume-a, който ще монтираме в конетейнера (трябва да съвпада с volumes[].name)
          mountPath: /var/opt/mssql         # Път в контейнера, където SQL Server пази data файловете
      volumes:                              # Дефинираме volume-и на ниво Pod (откъде идват)
      - name: identity-database-data        # Име на volume-a вътре в Pod-а (същото като във volumeMounts[].name)
        persistentVolumeClaim:              # Тип volume: от PVC
          claimName: identity-database-data # Име на PVC ресурса (metadata.name в identity-database.pvc.yml)